{"name":"Dado","tagline":"A Dependency Injection framework for Dart","body":"Dado\r\n====\r\n\r\nDado is a [dependency injection][di] framework for [Dart][dart].\r\n\r\nDado attempts to have minimal set of features and a syntax that takes advantage\r\nof Dart, which makes it different from many other popular DI frameworks.\r\n\r\nDado tries to make DI more lightweight by letting you define modules as Dart\r\nclasses and as declaratively as possible. Bindings can be define by simply\r\ndeclaring an abstract method:\r\n\r\n    class MyModule extends Module {\r\n      Foo get foo;\r\n    }\r\n\r\nSee the tests for more examples.\r\n\r\n[dart]: http://dartlang.org\r\n[di]: http://en.wikipedia.org/wiki/Dependency_injection \"Dependency Injection\"\r\n\r\nPrinciples\r\n----------\r\n\r\n  1. __Idiomatic:__ Dart is a different language than JavaScript or Java and has\r\n     different capabilities and styles. Part of Dado's approach is driven by a\r\n     desire to figure out exactly what a Dart DI framework should look like. We\r\n     try to use language features to drive configuration whenever possible.\r\n  2. __Dev-Time Productivity, Deploy-Time Optimization__ Dado uses Dart mirrors\r\n     to implement injectors dynamically, but we are working on a code generator\r\n     that will allow tools like dart2js to produce smaller output.\r\n  3. __Play Well with the Web:__ Dart is at home on the web and Dado should be\r\n     too, working well with the DOM, and new technologies like custom elements\r\n     and MDV.\r\n  4. __Simplicity__ Dado should be as simple as possible, but no simpler.\r\n  5. __Toolability__ Dado should work well tools and operations like static find\r\n     references, refactoring, minifiers, tree-shakers, etc.\r\n\r\n\r\nExample\r\n-------\r\n\r\n    import 'package:dado/dado.dart';\r\n\r\n    class MyModule extends Module {\r\n\r\n\t  // binding to an instance, similar to bind().toInstance() in Guice\r\n\t  String serverAddress = \"127.0.0.1\";\r\n\r\n\t  // Getters define a singleton, similar to bind().to().in(Singleton.class)\r\n\t  // in Guice\r\n\t  Foo get foo;\r\n\r\n\t  // Methods define a factory binding, similar to bind().to() in Guice\r\n\t  Bar newBar();\r\n\r\n\t  // Methods that delegate to bindTo() bind a type to a specific\r\n      // implementation of that type\r\n\t  Baz get baz => bindTo(Baz).singleton;\r\n\r\n      // Bindings can be made to provider methods\r\n\t  Qux newQux() => bindTo(Qux)\r\n\t      .providedBy((Foo foo) => new Qux(foo, 'not injected')).newInstance();\r\n\t}\r\n\r\n\tclass Bar {\r\n      // A default method is automatically injected with dependencies\r\n\t  Bar(Foo foo);\r\n\t}\r\n\r\n    main() {\r\n      var injector = new Injector([MyModule]);\r\n      Bar bar = injector.getInstance(Bar);\r\n    }\r\n\r\nStatus\r\n------\r\n\r\nDado is under active development. It has a few tests, but has not been used in\r\nproduction yet.\r\n\r\nKnown Issues and Limitations\r\n----------------------------\r\n\r\n * Injectable classes must either have a default constructor or a single\r\n   constructor.\r\n * There can only be one binding per type, because Dado doesn't use annotations\r\n   yet.\r\n * Functions cannot be injected yet.\r\n * Named parameters are not supported.\r\n * No custom scope support. The only scopes are unscoped and singleton.\r\n   Hierarchical modules might be enough.\r\n * Modules must extend `Module`. When mixins are better supported in Dart,\r\n   `Module` can be mixed in instead.\r\n\r\nStar Fishing\r\n------------\r\n\r\n * http://dartbug.com/5897 Look up classes by name\r\n * http://dartbug.com/9395 Get qualified name from Type\r\n * http://dartbug.com/8493 Access annotations via mirrors\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}